{"version":3,"file":"random-points.umd.js","sources":["webpack://geotools/./node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.min.js","webpack://geotools/webpack/runtime/define_property_getters","webpack://geotools/webpack/runtime/has_own_property","webpack://geotools/webpack/runtime/make_namespace_object","webpack://geotools/./node_modules/.pnpm/@turf+helpers@7.2.0/node_modules/@turf/helpers/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+meta@7.2.0/node_modules/@turf/meta/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+area@7.2.0/node_modules/@turf/area/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","webpack://geotools/./node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","webpack://geotools/./node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient3d.js","webpack://geotools/./node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/incircle.js","webpack://geotools/./node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/insphere.js","webpack://geotools/./node_modules/.pnpm/point-in-polygon-hao@1.2.4/node_modules/point-in-polygon-hao/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+invariant@7.2.0/node_modules/@turf/invariant/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+boolean-point-in-polygon@7.2.0/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+unkink-polygon@7.2.0/node_modules/@turf/unkink-polygon/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+random@7.2.0/node_modules/@turf/random/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+bbox@7.2.0/node_modules/@turf/bbox/dist/esm/index.js","webpack://geotools/./node_modules/.pnpm/@turf+points-within-polygon@7.2.0/node_modules/@turf/points-within-polygon/dist/esm/index.js","webpack://geotools/./src/turf.ts","webpack://geotools/./src/random-points.ts"],"sourcesContent":["!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { earthRadius } from \"@turf/helpers\";\nimport { geomReduce } from \"@turf/meta\";\nfunction area(geojson) {\n  return geomReduce(\n    geojson,\n    (value, geom) => {\n      return value + calculateArea(geom);\n    },\n    0\n  );\n}\nfunction calculateArea(geom) {\n  let total = 0;\n  let i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\nfunction polygonArea(coords) {\n  let total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (let i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\nvar FACTOR = earthRadius * earthRadius / 2;\nvar PI_OVER_180 = Math.PI / 180;\nfunction ringArea(coords) {\n  const coordsLength = coords.length - 1;\n  if (coordsLength <= 2) return 0;\n  let total = 0;\n  let i = 0;\n  while (i < coordsLength) {\n    const lower = coords[i];\n    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n    const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n    const lowerX = lower[0] * PI_OVER_180;\n    const middleY = middle[1] * PI_OVER_180;\n    const upperX = upper[0] * PI_OVER_180;\n    total += (upperX - lowerX) * Math.sin(middleY);\n    i++;\n  }\n  return total * FACTOR;\n}\nvar turf_area_default = area;\nexport {\n  area,\n  turf_area_default as default\n};\n//# sourceMappingURL=index.js.map","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum, scale} from './util.js';\n\nconst o3derrboundA = (7 + 56 * epsilon) * epsilon;\nconst o3derrboundB = (3 + 28 * epsilon) * epsilon;\nconst o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;\n\nconst bc = vec(4);\nconst ca = vec(4);\nconst ab = vec(4);\nconst at_b = vec(4);\nconst at_c = vec(4);\nconst bt_c = vec(4);\nconst bt_a = vec(4);\nconst ct_a = vec(4);\nconst ct_b = vec(4);\nconst bct = vec(8);\nconst cat = vec(8);\nconst abt = vec(8);\nconst u = vec(4);\n\nconst _8 = vec(8);\nconst _8b = vec(8);\nconst _16 = vec(8);\nconst _12 = vec(12);\n\nlet fin = vec(192);\nlet fin2 = vec(192);\n\nfunction finadd(finlen, alen, a) {\n    finlen = sum(finlen, fin, alen, a, fin2);\n    const tmp = fin; fin = fin2; fin2 = tmp;\n    return finlen;\n}\n\nfunction tailinit(xtail, ytail, ax, ay, bx, by, a, b) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3, negate;\n    if (xtail === 0) {\n        if (ytail === 0) {\n            a[0] = 0;\n            b[0] = 0;\n            return 1;\n        } else {\n            negate = -ytail;\n            s1 = negate * ax;\n            c = splitter * negate;\n            ahi = c - (c - negate);\n            alo = negate - ahi;\n            c = splitter * ax;\n            bhi = c - (c - ax);\n            blo = ax - bhi;\n            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            a[1] = s1;\n            s1 = ytail * bx;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * bx;\n            bhi = c - (c - bx);\n            blo = bx - bhi;\n            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            b[1] = s1;\n            return 2;\n        }\n    } else {\n        if (ytail === 0) {\n            s1 = xtail * ay;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * ay;\n            bhi = c - (c - ay);\n            blo = ay - bhi;\n            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            a[1] = s1;\n            negate = -xtail;\n            s1 = negate * by;\n            c = splitter * negate;\n            ahi = c - (c - negate);\n            alo = negate - ahi;\n            c = splitter * by;\n            bhi = c - (c - by);\n            blo = by - bhi;\n            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            b[1] = s1;\n            return 2;\n        } else {\n            s1 = xtail * ay;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * ay;\n            bhi = c - (c - ay);\n            blo = ay - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = ytail * ax;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * ax;\n            bhi = c - (c - ax);\n            blo = ax - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            a[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            a[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            a[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            a[3] = u3;\n            s1 = ytail * bx;\n            c = splitter * ytail;\n            ahi = c - (c - ytail);\n            alo = ytail - ahi;\n            c = splitter * bx;\n            bhi = c - (c - bx);\n            blo = bx - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = xtail * by;\n            c = splitter * xtail;\n            ahi = c - (c - xtail);\n            alo = xtail - ahi;\n            c = splitter * by;\n            bhi = c - (c - by);\n            blo = by - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            b[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            b[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            b[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            b[3] = u3;\n            return 4;\n        }\n    }\n}\n\nfunction tailadd(finlen, a, b, k, z) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, u3;\n    s1 = a * b;\n    c = splitter * a;\n    ahi = c - (c - a);\n    alo = a - ahi;\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    c = splitter * k;\n    bhi = c - (c - k);\n    blo = k - bhi;\n    _i = s0 * k;\n    c = splitter * s0;\n    ahi = c - (c - s0);\n    alo = s0 - ahi;\n    u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);\n    _j = s1 * k;\n    c = splitter * s1;\n    ahi = c - (c - s1);\n    alo = s1 - ahi;\n    _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);\n    _k = _i + _0;\n    bvirt = _k - _i;\n    u[1] = _i - (_k - bvirt) + (_0 - bvirt);\n    u3 = _j + _k;\n    u[2] = _k - (u3 - _j);\n    u[3] = u3;\n    finlen = finadd(finlen, 4, u);\n    if (z !== 0) {\n        c = splitter * z;\n        bhi = c - (c - z);\n        blo = z - bhi;\n        _i = s0 * z;\n        c = splitter * s0;\n        ahi = c - (c - s0);\n        alo = s0 - ahi;\n        u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);\n        _j = s1 * z;\n        c = splitter * s1;\n        ahi = c - (c - s1);\n        alo = s1 - ahi;\n        _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);\n        _k = _i + _0;\n        bvirt = _k - _i;\n        u[1] = _i - (_k - bvirt) + (_0 - bvirt);\n        u3 = _j + _k;\n        u[2] = _k - (u3 - _j);\n        u[3] = u3;\n        finlen = finadd(finlen, 4, u);\n    }\n    return finlen;\n}\n\nfunction orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent) {\n    let finlen;\n    let adxtail, bdxtail, cdxtail;\n    let adytail, bdytail, cdytail;\n    let adztail, bdztail, cdztail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3;\n\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    s1 = bdx * cdy;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cdx * bdy;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cdx * ady;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = adx * cdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ca[3] = u3;\n    s1 = adx * bdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bdx * ady;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n\n    finlen = sum(\n        sum(\n            scale(4, bc, adz, _8), _8,\n            scale(4, ca, bdz, _8b), _8b, _16), _16,\n        scale(4, ab, cdz, _8), _8, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = o3derrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - adx;\n    adxtail = ax - (adx + bvirt) + (bvirt - dx);\n    bvirt = bx - bdx;\n    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);\n    bvirt = cx - cdx;\n    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);\n    bvirt = ay - ady;\n    adytail = ay - (ady + bvirt) + (bvirt - dy);\n    bvirt = by - bdy;\n    bdytail = by - (bdy + bvirt) + (bvirt - dy);\n    bvirt = cy - cdy;\n    cdytail = cy - (cdy + bvirt) + (bvirt - dy);\n    bvirt = az - adz;\n    adztail = az - (adz + bvirt) + (bvirt - dz);\n    bvirt = bz - bdz;\n    bdztail = bz - (bdz + bvirt) + (bvirt - dz);\n    bvirt = cz - cdz;\n    cdztail = cz - (cdz + bvirt) + (bvirt - dz);\n\n    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 &&\n        adytail === 0 && bdytail === 0 && cdytail === 0 &&\n        adztail === 0 && bdztail === 0 && cdztail === 0) {\n        return det;\n    }\n\n    errbound = o3derrboundC * permanent + resulterrbound * Math.abs(det);\n    det +=\n        adz * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + adztail * (bdx * cdy - bdy * cdx) +\n        bdz * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + bdztail * (cdx * ady - cdy * adx) +\n        cdz * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + cdztail * (adx * bdy - ady * bdx);\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    const at_len = tailinit(adxtail, adytail, bdx, bdy, cdx, cdy, at_b, at_c);\n    const bt_len = tailinit(bdxtail, bdytail, cdx, cdy, adx, ady, bt_c, bt_a);\n    const ct_len = tailinit(cdxtail, cdytail, adx, ady, bdx, bdy, ct_a, ct_b);\n\n    const bctlen = sum(bt_len, bt_c, ct_len, ct_b, bct);\n    finlen = finadd(finlen, scale(bctlen, bct, adz, _16), _16);\n\n    const catlen = sum(ct_len, ct_a, at_len, at_c, cat);\n    finlen = finadd(finlen, scale(catlen, cat, bdz, _16), _16);\n\n    const abtlen = sum(at_len, at_b, bt_len, bt_a, abt);\n    finlen = finadd(finlen, scale(abtlen, abt, cdz, _16), _16);\n\n    if (adztail !== 0) {\n        finlen = finadd(finlen, scale(4, bc, adztail, _12), _12);\n        finlen = finadd(finlen, scale(bctlen, bct, adztail, _16), _16);\n    }\n    if (bdztail !== 0) {\n        finlen = finadd(finlen, scale(4, ca, bdztail, _12), _12);\n        finlen = finadd(finlen, scale(catlen, cat, bdztail, _16), _16);\n    }\n    if (cdztail !== 0) {\n        finlen = finadd(finlen, scale(4, ab, cdztail, _12), _12);\n        finlen = finadd(finlen, scale(abtlen, abt, cdztail, _16), _16);\n    }\n\n    if (adxtail !== 0) {\n        if (bdytail !== 0) {\n            finlen = tailadd(finlen, adxtail, bdytail, cdz, cdztail);\n        }\n        if (cdytail !== 0) {\n            finlen = tailadd(finlen, -adxtail, cdytail, bdz, bdztail);\n        }\n    }\n    if (bdxtail !== 0) {\n        if (cdytail !== 0) {\n            finlen = tailadd(finlen, bdxtail, cdytail, adz, adztail);\n        }\n        if (adytail !== 0) {\n            finlen = tailadd(finlen, -bdxtail, adytail, cdz, cdztail);\n        }\n    }\n    if (cdxtail !== 0) {\n        if (adytail !== 0) {\n            finlen = tailadd(finlen, cdxtail, adytail, bdz, bdztail);\n        }\n        if (bdytail !== 0) {\n            finlen = tailadd(finlen, -cdxtail, bdytail, adz, adztail);\n        }\n    }\n\n    return fin[finlen - 1];\n}\n\nexport function orient3d(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    const bdxcdy = bdx * cdy;\n    const cdxbdy = cdx * bdy;\n\n    const cdxady = cdx * ady;\n    const adxcdy = adx * cdy;\n\n    const adxbdy = adx * bdy;\n    const bdxady = bdx * ady;\n\n    const det =\n        adz * (bdxcdy - cdxbdy) +\n        bdz * (cdxady - adxcdy) +\n        cdz * (adxbdy - bdxady);\n\n    const permanent =\n        (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) +\n        (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) +\n        (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);\n\n    const errbound = o3derrboundA * permanent;\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n\n    return orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent);\n}\n\nexport function orient3dfast(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n    const adz = az - dz;\n    const bdz = bz - dz;\n    const cdz = cz - dz;\n\n    return adx * (bdy * cdz - bdz * cdy) +\n        bdx * (cdy * adz - cdz * ady) +\n        cdx * (ady * bdz - adz * bdy);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum, sum_three, scale} from './util.js';\n\nconst iccerrboundA = (10 + 96 * epsilon) * epsilon;\nconst iccerrboundB = (4 + 48 * epsilon) * epsilon;\nconst iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;\n\nconst bc = vec(4);\nconst ca = vec(4);\nconst ab = vec(4);\nconst aa = vec(4);\nconst bb = vec(4);\nconst cc = vec(4);\nconst u = vec(4);\nconst v = vec(4);\nconst axtbc = vec(8);\nconst aytbc = vec(8);\nconst bxtca = vec(8);\nconst bytca = vec(8);\nconst cxtab = vec(8);\nconst cytab = vec(8);\nconst abt = vec(8);\nconst bct = vec(8);\nconst cat = vec(8);\nconst abtt = vec(4);\nconst bctt = vec(4);\nconst catt = vec(4);\n\nconst _8 = vec(8);\nconst _16 = vec(16);\nconst _16b = vec(16);\nconst _16c = vec(16);\nconst _32 = vec(32);\nconst _32b = vec(32);\nconst _48 = vec(48);\nconst _64 = vec(64);\n\nlet fin = vec(1152);\nlet fin2 = vec(1152);\n\nfunction finadd(finlen, a, alen) {\n    finlen = sum(finlen, fin, a, alen, fin2);\n    const tmp = fin; fin = fin2; fin2 = tmp;\n    return finlen;\n}\n\nfunction incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {\n    let finlen;\n    let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;\n    let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;\n    let abtlen, bctlen, catlen;\n    let abttlen, bcttlen, cattlen;\n    let n1, n0;\n\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n\n    s1 = bdx * cdy;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cdx * bdy;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cdx * ady;\n    c = splitter * cdx;\n    ahi = c - (c - cdx);\n    alo = cdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = adx * cdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * cdy;\n    bhi = c - (c - cdy);\n    blo = cdy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ca[3] = u3;\n    s1 = adx * bdy;\n    c = splitter * adx;\n    ahi = c - (c - adx);\n    alo = adx - ahi;\n    c = splitter * bdy;\n    bhi = c - (c - bdy);\n    blo = bdy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bdx * ady;\n    c = splitter * bdx;\n    ahi = c - (c - bdx);\n    alo = bdx - ahi;\n    c = splitter * ady;\n    bhi = c - (c - ady);\n    blo = ady - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n\n    finlen = sum(\n        sum(\n            sum(\n                scale(scale(4, bc, adx, _8), _8, adx, _16), _16,\n                scale(scale(4, bc, ady, _8), _8, ady, _16b), _16b, _32), _32,\n            sum(\n                scale(scale(4, ca, bdx, _8), _8, bdx, _16), _16,\n                scale(scale(4, ca, bdy, _8), _8, bdy, _16b), _16b, _32b), _32b, _64), _64,\n        sum(\n            scale(scale(4, ab, cdx, _8), _8, cdx, _16), _16,\n            scale(scale(4, ab, cdy, _8), _8, cdy, _16b), _16b, _32), _32, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = iccerrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - adx;\n    adxtail = ax - (adx + bvirt) + (bvirt - dx);\n    bvirt = ay - ady;\n    adytail = ay - (ady + bvirt) + (bvirt - dy);\n    bvirt = bx - bdx;\n    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);\n    bvirt = by - bdy;\n    bdytail = by - (bdy + bvirt) + (bvirt - dy);\n    bvirt = cx - cdx;\n    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);\n    bvirt = cy - cdy;\n    cdytail = cy - (cdy + bvirt) + (bvirt - dy);\n    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {\n        return det;\n    }\n\n    errbound = iccerrboundC * permanent + resulterrbound * Math.abs(det);\n    det += ((adx * adx + ady * ady) * ((bdx * cdytail + cdy * bdxtail) - (bdy * cdxtail + cdx * bdytail)) +\n        2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx)) +\n        ((bdx * bdx + bdy * bdy) * ((cdx * adytail + ady * cdxtail) - (cdy * adxtail + adx * cdytail)) +\n        2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) +\n        ((cdx * cdx + cdy * cdy) * ((adx * bdytail + bdy * adxtail) - (ady * bdxtail + bdx * adytail)) +\n        2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));\n\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {\n        s1 = adx * adx;\n        c = splitter * adx;\n        ahi = c - (c - adx);\n        alo = adx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = ady * ady;\n        c = splitter * ady;\n        ahi = c - (c - ady);\n        alo = ady - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        aa[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        aa[3] = u3;\n    }\n    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {\n        s1 = bdx * bdx;\n        c = splitter * bdx;\n        ahi = c - (c - bdx);\n        alo = bdx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = bdy * bdy;\n        c = splitter * bdy;\n        ahi = c - (c - bdy);\n        alo = bdy - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        bb[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        bb[3] = u3;\n    }\n    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {\n        s1 = cdx * cdx;\n        c = splitter * cdx;\n        ahi = c - (c - cdx);\n        alo = cdx - ahi;\n        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);\n        t1 = cdy * cdy;\n        c = splitter * cdy;\n        ahi = c - (c - cdy);\n        alo = cdy - ahi;\n        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);\n        _i = s0 + t0;\n        bvirt = _i - s0;\n        cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 + t1;\n        bvirt = _i - _0;\n        cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        cc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        cc[3] = u3;\n    }\n\n    if (adxtail !== 0) {\n        axtbclen = scale(4, bc, adxtail, axtbc);\n        finlen = finadd(finlen, sum_three(\n            scale(axtbclen, axtbc, 2 * adx, _16), _16,\n            scale(scale(4, cc, adxtail, _8), _8, bdy, _16b), _16b,\n            scale(scale(4, bb, adxtail, _8), _8, -cdy, _16c), _16c, _32, _48), _48);\n    }\n    if (adytail !== 0) {\n        aytbclen = scale(4, bc, adytail, aytbc);\n        finlen = finadd(finlen, sum_three(\n            scale(aytbclen, aytbc, 2 * ady, _16), _16,\n            scale(scale(4, bb, adytail, _8), _8, cdx, _16b), _16b,\n            scale(scale(4, cc, adytail, _8), _8, -bdx, _16c), _16c, _32, _48), _48);\n    }\n    if (bdxtail !== 0) {\n        bxtcalen = scale(4, ca, bdxtail, bxtca);\n        finlen = finadd(finlen, sum_three(\n            scale(bxtcalen, bxtca, 2 * bdx, _16), _16,\n            scale(scale(4, aa, bdxtail, _8), _8, cdy, _16b), _16b,\n            scale(scale(4, cc, bdxtail, _8), _8, -ady, _16c), _16c, _32, _48), _48);\n    }\n    if (bdytail !== 0) {\n        bytcalen = scale(4, ca, bdytail, bytca);\n        finlen = finadd(finlen, sum_three(\n            scale(bytcalen, bytca, 2 * bdy, _16), _16,\n            scale(scale(4, cc, bdytail, _8), _8, adx, _16b), _16b,\n            scale(scale(4, aa, bdytail, _8), _8, -cdx, _16c), _16c, _32, _48), _48);\n    }\n    if (cdxtail !== 0) {\n        cxtablen = scale(4, ab, cdxtail, cxtab);\n        finlen = finadd(finlen, sum_three(\n            scale(cxtablen, cxtab, 2 * cdx, _16), _16,\n            scale(scale(4, bb, cdxtail, _8), _8, ady, _16b), _16b,\n            scale(scale(4, aa, cdxtail, _8), _8, -bdy, _16c), _16c, _32, _48), _48);\n    }\n    if (cdytail !== 0) {\n        cytablen = scale(4, ab, cdytail, cytab);\n        finlen = finadd(finlen, sum_three(\n            scale(cytablen, cytab, 2 * cdy, _16), _16,\n            scale(scale(4, aa, cdytail, _8), _8, bdx, _16b), _16b,\n            scale(scale(4, bb, cdytail, _8), _8, -adx, _16c), _16c, _32, _48), _48);\n    }\n\n    if (adxtail !== 0 || adytail !== 0) {\n        if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {\n            s1 = bdxtail * cdy;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * cdy;\n            bhi = c - (c - cdy);\n            blo = cdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdx * cdytail;\n            c = splitter * bdx;\n            ahi = c - (c - bdx);\n            alo = bdx - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            s1 = cdxtail * -bdy;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * -bdy;\n            bhi = c - (c - -bdy);\n            blo = -bdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdx * -bdytail;\n            c = splitter * cdx;\n            ahi = c - (c - cdx);\n            alo = cdx - ahi;\n            c = splitter * -bdytail;\n            bhi = c - (c - -bdytail);\n            blo = -bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            bctlen = sum(4, u, 4, v, bct);\n            s1 = bdxtail * cdytail;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdxtail * bdytail;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            bctt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            bctt[3] = u3;\n            bcttlen = 4;\n        } else {\n            bct[0] = 0;\n            bctlen = 1;\n            bctt[0] = 0;\n            bcttlen = 1;\n        }\n        if (adxtail !== 0) {\n            const len = scale(bctlen, bct, adxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(axtbclen, axtbc, adxtail, _16), _16,\n                scale(len, _16c, 2 * adx, _32), _32, _48), _48);\n\n            const len2 = scale(bcttlen, bctt, adxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * adx, _16), _16,\n                scale(len2, _8, adxtail, _16b), _16b,\n                scale(len, _16c, adxtail, _32), _32, _32b, _64), _64);\n\n            if (bdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, cc, adxtail, _8), _8, bdytail, _16), _16);\n            }\n            if (cdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, bb, -adxtail, _8), _8, cdytail, _16), _16);\n            }\n        }\n        if (adytail !== 0) {\n            const len = scale(bctlen, bct, adytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(aytbclen, aytbc, adytail, _16), _16,\n                scale(len, _16c, 2 * ady, _32), _32, _48), _48);\n\n            const len2 = scale(bcttlen, bctt, adytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * ady, _16), _16,\n                scale(len2, _8, adytail, _16b), _16b,\n                scale(len, _16c, adytail, _32), _32, _32b, _64), _64);\n        }\n    }\n    if (bdxtail !== 0 || bdytail !== 0) {\n        if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {\n            s1 = cdxtail * ady;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * ady;\n            bhi = c - (c - ady);\n            blo = ady - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = cdx * adytail;\n            c = splitter * cdx;\n            ahi = c - (c - cdx);\n            alo = cdx - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            n1 = -cdy;\n            n0 = -cdytail;\n            s1 = adxtail * n1;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * n1;\n            bhi = c - (c - n1);\n            blo = n1 - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adx * n0;\n            c = splitter * adx;\n            ahi = c - (c - adx);\n            alo = adx - ahi;\n            c = splitter * n0;\n            bhi = c - (c - n0);\n            blo = n0 - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            catlen = sum(4, u, 4, v, cat);\n            s1 = cdxtail * adytail;\n            c = splitter * cdxtail;\n            ahi = c - (c - cdxtail);\n            alo = cdxtail - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adxtail * cdytail;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * cdytail;\n            bhi = c - (c - cdytail);\n            blo = cdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            catt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            catt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            catt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            catt[3] = u3;\n            cattlen = 4;\n        } else {\n            cat[0] = 0;\n            catlen = 1;\n            catt[0] = 0;\n            cattlen = 1;\n        }\n        if (bdxtail !== 0) {\n            const len = scale(catlen, cat, bdxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(bxtcalen, bxtca, bdxtail, _16), _16,\n                scale(len, _16c, 2 * bdx, _32), _32, _48), _48);\n\n            const len2 = scale(cattlen, catt, bdxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * bdx, _16), _16,\n                scale(len2, _8, bdxtail, _16b), _16b,\n                scale(len, _16c, bdxtail, _32), _32, _32b, _64), _64);\n\n            if (cdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, aa, bdxtail, _8), _8, cdytail, _16), _16);\n            }\n            if (adytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, cc, -bdxtail, _8), _8, adytail, _16), _16);\n            }\n        }\n        if (bdytail !== 0) {\n            const len = scale(catlen, cat, bdytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(bytcalen, bytca, bdytail, _16), _16,\n                scale(len, _16c, 2 * bdy, _32), _32, _48), _48);\n\n            const len2 = scale(cattlen, catt, bdytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * bdy, _16), _16,\n                scale(len2, _8, bdytail, _16b), _16b,\n                scale(len, _16c, bdytail, _32), _32,  _32b, _64), _64);\n        }\n    }\n    if (cdxtail !== 0 || cdytail !== 0) {\n        if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {\n            s1 = adxtail * bdy;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * bdy;\n            bhi = c - (c - bdy);\n            blo = bdy - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = adx * bdytail;\n            c = splitter * adx;\n            ahi = c - (c - adx);\n            alo = adx - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            u[3] = u3;\n            n1 = -ady;\n            n0 = -adytail;\n            s1 = bdxtail * n1;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * n1;\n            bhi = c - (c - n1);\n            blo = n1 - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdx * n0;\n            c = splitter * bdx;\n            ahi = c - (c - bdx);\n            alo = bdx - ahi;\n            c = splitter * n0;\n            bhi = c - (c - n0);\n            blo = n0 - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 + t0;\n            bvirt = _i - s0;\n            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 + t1;\n            bvirt = _i - _0;\n            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            v[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            v[3] = u3;\n            abtlen = sum(4, u, 4, v, abt);\n            s1 = adxtail * bdytail;\n            c = splitter * adxtail;\n            ahi = c - (c - adxtail);\n            alo = adxtail - ahi;\n            c = splitter * bdytail;\n            bhi = c - (c - bdytail);\n            blo = bdytail - bhi;\n            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n            t1 = bdxtail * adytail;\n            c = splitter * bdxtail;\n            ahi = c - (c - bdxtail);\n            alo = bdxtail - ahi;\n            c = splitter * adytail;\n            bhi = c - (c - adytail);\n            blo = adytail - bhi;\n            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n            _i = s0 - t0;\n            bvirt = s0 - _i;\n            abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);\n            _j = s1 + _i;\n            bvirt = _j - s1;\n            _0 = s1 - (_j - bvirt) + (_i - bvirt);\n            _i = _0 - t1;\n            bvirt = _0 - _i;\n            abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);\n            u3 = _j + _i;\n            bvirt = u3 - _j;\n            abtt[2] = _j - (u3 - bvirt) + (_i - bvirt);\n            abtt[3] = u3;\n            abttlen = 4;\n        } else {\n            abt[0] = 0;\n            abtlen = 1;\n            abtt[0] = 0;\n            abttlen = 1;\n        }\n        if (cdxtail !== 0) {\n            const len = scale(abtlen, abt, cdxtail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(cxtablen, cxtab, cdxtail, _16), _16,\n                scale(len, _16c, 2 * cdx, _32), _32, _48), _48);\n\n            const len2 = scale(abttlen, abtt, cdxtail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * cdx, _16), _16,\n                scale(len2, _8, cdxtail, _16b), _16b,\n                scale(len, _16c, cdxtail, _32), _32, _32b, _64), _64);\n\n            if (adytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, bb, cdxtail, _8), _8, adytail, _16), _16);\n            }\n            if (bdytail !== 0) {\n                finlen = finadd(finlen, scale(scale(4, aa, -cdxtail, _8), _8, bdytail, _16), _16);\n            }\n        }\n        if (cdytail !== 0) {\n            const len = scale(abtlen, abt, cdytail, _16c);\n            finlen = finadd(finlen, sum(\n                scale(cytablen, cytab, cdytail, _16), _16,\n                scale(len, _16c, 2 * cdy, _32), _32, _48), _48);\n\n            const len2 = scale(abttlen, abtt, cdytail, _8);\n            finlen = finadd(finlen, sum_three(\n                scale(len2, _8, 2 * cdy, _16), _16,\n                scale(len2, _8, cdytail, _16b), _16b,\n                scale(len, _16c, cdytail, _32), _32, _32b, _64), _64);\n        }\n    }\n\n    return fin[finlen - 1];\n}\n\nexport function incircle(ax, ay, bx, by, cx, cy, dx, dy) {\n    const adx = ax - dx;\n    const bdx = bx - dx;\n    const cdx = cx - dx;\n    const ady = ay - dy;\n    const bdy = by - dy;\n    const cdy = cy - dy;\n\n    const bdxcdy = bdx * cdy;\n    const cdxbdy = cdx * bdy;\n    const alift = adx * adx + ady * ady;\n\n    const cdxady = cdx * ady;\n    const adxcdy = adx * cdy;\n    const blift = bdx * bdx + bdy * bdy;\n\n    const adxbdy = adx * bdy;\n    const bdxady = bdx * ady;\n    const clift = cdx * cdx + cdy * cdy;\n\n    const det =\n        alift * (bdxcdy - cdxbdy) +\n        blift * (cdxady - adxcdy) +\n        clift * (adxbdy - bdxady);\n\n    const permanent =\n        (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift +\n        (Math.abs(cdxady) + Math.abs(adxcdy)) * blift +\n        (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;\n\n    const errbound = iccerrboundA * permanent;\n\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n    return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);\n}\n\nexport function incirclefast(ax, ay, bx, by, cx, cy, dx, dy) {\n    const adx = ax - dx;\n    const ady = ay - dy;\n    const bdx = bx - dx;\n    const bdy = by - dy;\n    const cdx = cx - dx;\n    const cdy = cy - dy;\n\n    const abdet = adx * bdy - bdx * ady;\n    const bcdet = bdx * cdy - cdx * bdy;\n    const cadet = cdx * ady - adx * cdy;\n    const alift = adx * adx + ady * ady;\n    const blift = bdx * bdx + bdy * bdy;\n    const clift = cdx * cdx + cdy * cdy;\n\n    return alift * bcdet + blift * cadet + clift * abdet;\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum, sum_three, scale, negate} from './util.js';\n\nconst isperrboundA = (16 + 224 * epsilon) * epsilon;\nconst isperrboundB = (5 + 72 * epsilon) * epsilon;\nconst isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;\n\nconst ab = vec(4);\nconst bc = vec(4);\nconst cd = vec(4);\nconst de = vec(4);\nconst ea = vec(4);\nconst ac = vec(4);\nconst bd = vec(4);\nconst ce = vec(4);\nconst da = vec(4);\nconst eb = vec(4);\n\nconst abc = vec(24);\nconst bcd = vec(24);\nconst cde = vec(24);\nconst dea = vec(24);\nconst eab = vec(24);\nconst abd = vec(24);\nconst bce = vec(24);\nconst cda = vec(24);\nconst deb = vec(24);\nconst eac = vec(24);\n\nconst adet = vec(1152);\nconst bdet = vec(1152);\nconst cdet = vec(1152);\nconst ddet = vec(1152);\nconst edet = vec(1152);\nconst abdet = vec(2304);\nconst cddet = vec(2304);\nconst cdedet = vec(3456);\nconst deter = vec(5760);\n\nconst _8 = vec(8);\nconst _8b = vec(8);\nconst _8c = vec(8);\nconst _16 = vec(16);\nconst _24 = vec(24);\nconst _48 = vec(48);\nconst _48b = vec(48);\nconst _96 = vec(96);\nconst _192 = vec(192);\nconst _384x = vec(384);\nconst _384y = vec(384);\nconst _384z = vec(384);\nconst _768 = vec(768);\n\nfunction sum_three_scale(a, b, c, az, bz, cz, out) {\n    return sum_three(\n        scale(4, a, az, _8), _8,\n        scale(4, b, bz, _8b), _8b,\n        scale(4, c, cz, _8c), _8c, _16, out);\n}\n\nfunction liftexact(alen, a, blen, b, clen, c, dlen, d, x, y, z, out) {\n    const len = sum(\n        sum(alen, a, blen, b, _48), _48,\n        negate(sum(clen, c, dlen, d, _48b), _48b), _48b, _96);\n\n    return sum_three(\n        scale(scale(len, _96, x, _192), _192, x, _384x), _384x,\n        scale(scale(len, _96, y, _192), _192, y, _384y), _384y,\n        scale(scale(len, _96, z, _192), _192, z, _384z), _384z, _768, out);\n}\n\nfunction insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    s1 = ax * by;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bx * ay;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ab[3] = u3;\n    s1 = bx * cy;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cx * by;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bc[3] = u3;\n    s1 = cx * dy;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dx * cy;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    cd[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    cd[3] = u3;\n    s1 = dx * ey;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ex * dy;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    de[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    de[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    de[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    de[3] = u3;\n    s1 = ex * ay;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ax * ey;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ea[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ea[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ea[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ea[3] = u3;\n    s1 = ax * cy;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cx * ay;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ac[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ac[3] = u3;\n    s1 = bx * dy;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dx * by;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    bd[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    bd[3] = u3;\n    s1 = cx * ey;\n    c = splitter * cx;\n    ahi = c - (c - cx);\n    alo = cx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ex * cy;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * cy;\n    bhi = c - (c - cy);\n    blo = cy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ce[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ce[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    ce[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    ce[3] = u3;\n    s1 = dx * ay;\n    c = splitter * dx;\n    ahi = c - (c - dx);\n    alo = dx - ahi;\n    c = splitter * ay;\n    bhi = c - (c - ay);\n    blo = ay - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = ax * dy;\n    c = splitter * ax;\n    ahi = c - (c - ax);\n    alo = ax - ahi;\n    c = splitter * dy;\n    bhi = c - (c - dy);\n    blo = dy - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    da[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    da[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    da[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    da[3] = u3;\n    s1 = ex * by;\n    c = splitter * ex;\n    ahi = c - (c - ex);\n    alo = ex - ahi;\n    c = splitter * by;\n    bhi = c - (c - by);\n    blo = by - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bx * ey;\n    c = splitter * bx;\n    ahi = c - (c - bx);\n    alo = bx - ahi;\n    c = splitter * ey;\n    bhi = c - (c - ey);\n    blo = ey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    eb[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    eb[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    eb[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    eb[3] = u3;\n\n    const abclen = sum_three_scale(ab, bc, ac, cz, az, -bz, abc);\n    const bcdlen = sum_three_scale(bc, cd, bd, dz, bz, -cz, bcd);\n    const cdelen = sum_three_scale(cd, de, ce, ez, cz, -dz, cde);\n    const dealen = sum_three_scale(de, ea, da, az, dz, -ez, dea);\n    const eablen = sum_three_scale(ea, ab, eb, bz, ez, -az, eab);\n    const abdlen = sum_three_scale(ab, bd, da, dz, az, bz, abd);\n    const bcelen = sum_three_scale(bc, ce, eb, ez, bz, cz, bce);\n    const cdalen = sum_three_scale(cd, da, ac, az, cz, dz, cda);\n    const deblen = sum_three_scale(de, eb, bd, bz, dz, ez, deb);\n    const eaclen = sum_three_scale(ea, ac, ce, cz, ez, az, eac);\n\n    const deterlen = sum_three(\n        liftexact(cdelen, cde, bcelen, bce, deblen, deb, bcdlen, bcd, ax, ay, az, adet), adet,\n        liftexact(dealen, dea, cdalen, cda, eaclen, eac, cdelen, cde, bx, by, bz, bdet), bdet,\n        sum_three(\n            liftexact(eablen, eab, deblen, deb, abdlen, abd, dealen, dea, cx, cy, cz, cdet), cdet,\n            liftexact(abclen, abc, eaclen, eac, bcelen, bce, eablen, eab, dx, dy, dz, ddet), ddet,\n            liftexact(bcdlen, bcd, abdlen, abd, cdalen, cda, abclen, abc, ex, ey, ez, edet), edet, cddet, cdedet), cdedet, abdet, deter);\n\n    return deter[deterlen - 1];\n}\n\nconst xdet = vec(96);\nconst ydet = vec(96);\nconst zdet = vec(96);\nconst fin = vec(1152);\n\nfunction liftadapt(a, b, c, az, bz, cz, x, y, z, out) {\n    const len = sum_three_scale(a, b, c, az, bz, cz, _24);\n    return sum_three(\n        scale(scale(len, _24, x, _48), _48, x, xdet), xdet,\n        scale(scale(len, _24, y, _48), _48, y, ydet), ydet,\n        scale(scale(len, _24, z, _48), _48, z, zdet), zdet, _192, out);\n}\n\nfunction insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent) {\n    let ab3, bc3, cd3, da3, ac3, bd3;\n\n    let aextail, bextail, cextail, dextail;\n    let aeytail, beytail, ceytail, deytail;\n    let aeztail, beztail, ceztail, deztail;\n\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0;\n\n    const aex = ax - ex;\n    const bex = bx - ex;\n    const cex = cx - ex;\n    const dex = dx - ex;\n    const aey = ay - ey;\n    const bey = by - ey;\n    const cey = cy - ey;\n    const dey = dy - ey;\n    const aez = az - ez;\n    const bez = bz - ez;\n    const cez = cz - ez;\n    const dez = dz - ez;\n\n    s1 = aex * bey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = bex * aey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    ab3 = _j + _i;\n    bvirt = ab3 - _j;\n    ab[2] = _j - (ab3 - bvirt) + (_i - bvirt);\n    ab[3] = ab3;\n    s1 = bex * cey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cex * bey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    bc3 = _j + _i;\n    bvirt = bc3 - _j;\n    bc[2] = _j - (bc3 - bvirt) + (_i - bvirt);\n    bc[3] = bc3;\n    s1 = cex * dey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dex * cey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    cd3 = _j + _i;\n    bvirt = cd3 - _j;\n    cd[2] = _j - (cd3 - bvirt) + (_i - bvirt);\n    cd[3] = cd3;\n    s1 = dex * aey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = aex * dey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    da[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    da[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    da3 = _j + _i;\n    bvirt = da3 - _j;\n    da[2] = _j - (da3 - bvirt) + (_i - bvirt);\n    da[3] = da3;\n    s1 = aex * cey;\n    c = splitter * aex;\n    ahi = c - (c - aex);\n    alo = aex - ahi;\n    c = splitter * cey;\n    bhi = c - (c - cey);\n    blo = cey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = cex * aey;\n    c = splitter * cex;\n    ahi = c - (c - cex);\n    alo = cex - ahi;\n    c = splitter * aey;\n    bhi = c - (c - aey);\n    blo = aey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    ac3 = _j + _i;\n    bvirt = ac3 - _j;\n    ac[2] = _j - (ac3 - bvirt) + (_i - bvirt);\n    ac[3] = ac3;\n    s1 = bex * dey;\n    c = splitter * bex;\n    ahi = c - (c - bex);\n    alo = bex - ahi;\n    c = splitter * dey;\n    bhi = c - (c - dey);\n    blo = dey - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = dex * bey;\n    c = splitter * dex;\n    ahi = c - (c - dex);\n    alo = dex - ahi;\n    c = splitter * bey;\n    bhi = c - (c - bey);\n    blo = bey - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    bd3 = _j + _i;\n    bvirt = bd3 - _j;\n    bd[2] = _j - (bd3 - bvirt) + (_i - bvirt);\n    bd[3] = bd3;\n\n    const finlen = sum(\n        sum(\n            negate(liftadapt(bc, cd, bd, dez, bez, -cez, aex, aey, aez, adet), adet), adet,\n            liftadapt(cd, da, ac, aez, cez, dez, bex, bey, bez, bdet), bdet, abdet), abdet,\n        sum(\n            negate(liftadapt(da, ab, bd, bez, dez, aez, cex, cey, cez, cdet), cdet), cdet,\n            liftadapt(ab, bc, ac, cez, aez, -bez, dex, dey, dez, ddet), ddet, cddet), cddet, fin);\n\n    let det = estimate(finlen, fin);\n    let errbound = isperrboundB * permanent;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - aex;\n    aextail = ax - (aex + bvirt) + (bvirt - ex);\n    bvirt = ay - aey;\n    aeytail = ay - (aey + bvirt) + (bvirt - ey);\n    bvirt = az - aez;\n    aeztail = az - (aez + bvirt) + (bvirt - ez);\n    bvirt = bx - bex;\n    bextail = bx - (bex + bvirt) + (bvirt - ex);\n    bvirt = by - bey;\n    beytail = by - (bey + bvirt) + (bvirt - ey);\n    bvirt = bz - bez;\n    beztail = bz - (bez + bvirt) + (bvirt - ez);\n    bvirt = cx - cex;\n    cextail = cx - (cex + bvirt) + (bvirt - ex);\n    bvirt = cy - cey;\n    ceytail = cy - (cey + bvirt) + (bvirt - ey);\n    bvirt = cz - cez;\n    ceztail = cz - (cez + bvirt) + (bvirt - ez);\n    bvirt = dx - dex;\n    dextail = dx - (dex + bvirt) + (bvirt - ex);\n    bvirt = dy - dey;\n    deytail = dy - (dey + bvirt) + (bvirt - ey);\n    bvirt = dz - dez;\n    deztail = dz - (dez + bvirt) + (bvirt - ez);\n    if (aextail === 0 && aeytail === 0 && aeztail === 0 &&\n        bextail === 0 && beytail === 0 && beztail === 0 &&\n        cextail === 0 && ceytail === 0 && ceztail === 0 &&\n        dextail === 0 && deytail === 0 && deztail === 0) {\n        return det;\n    }\n\n    errbound = isperrboundC * permanent + resulterrbound * Math.abs(det);\n\n    const abeps = (aex * beytail + bey * aextail) - (aey * bextail + bex * aeytail);\n    const bceps = (bex * ceytail + cey * bextail) - (bey * cextail + cex * beytail);\n    const cdeps = (cex * deytail + dey * cextail) - (cey * dextail + dex * ceytail);\n    const daeps = (dex * aeytail + aey * dextail) - (dey * aextail + aex * deytail);\n    const aceps = (aex * ceytail + cey * aextail) - (aey * cextail + cex * aeytail);\n    const bdeps = (bex * deytail + dey * bextail) - (bey * dextail + dex * beytail);\n    det +=\n        (((bex * bex + bey * bey + bez * bez) * ((cez * daeps + dez * aceps + aez * cdeps) +\n        (ceztail * da3 + deztail * ac3 + aeztail * cd3)) + (dex * dex + dey * dey + dez * dez) *\n        ((aez * bceps - bez * aceps + cez * abeps) + (aeztail * bc3 - beztail * ac3 + ceztail * ab3))) -\n        ((aex * aex + aey * aey + aez * aez) * ((bez * cdeps - cez * bdeps + dez * bceps) +\n        (beztail * cd3 - ceztail * bd3 + deztail * bc3)) + (cex * cex + cey * cey + cez * cez) *\n        ((dez * abeps + aez * bdeps + bez * daeps) + (deztail * ab3 + aeztail * bd3 + beztail * da3)))) +\n        2 * (((bex * bextail + bey * beytail + bez * beztail) * (cez * da3 + dez * ac3 + aez * cd3) +\n        (dex * dextail + dey * deytail + dez * deztail) * (aez * bc3 - bez * ac3 + cez * ab3)) -\n        ((aex * aextail + aey * aeytail + aez * aeztail) * (bez * cd3 - cez * bd3 + dez * bc3) +\n        (cex * cextail + cey * ceytail + cez * ceztail) * (dez * ab3 + aez * bd3 + bez * da3)));\n\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    return insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez);\n}\n\nexport function insphere(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {\n    const aex = ax - ex;\n    const bex = bx - ex;\n    const cex = cx - ex;\n    const dex = dx - ex;\n    const aey = ay - ey;\n    const bey = by - ey;\n    const cey = cy - ey;\n    const dey = dy - ey;\n    const aez = az - ez;\n    const bez = bz - ez;\n    const cez = cz - ez;\n    const dez = dz - ez;\n\n    const aexbey = aex * bey;\n    const bexaey = bex * aey;\n    const ab = aexbey - bexaey;\n    const bexcey = bex * cey;\n    const cexbey = cex * bey;\n    const bc = bexcey - cexbey;\n    const cexdey = cex * dey;\n    const dexcey = dex * cey;\n    const cd = cexdey - dexcey;\n    const dexaey = dex * aey;\n    const aexdey = aex * dey;\n    const da = dexaey - aexdey;\n    const aexcey = aex * cey;\n    const cexaey = cex * aey;\n    const ac = aexcey - cexaey;\n    const bexdey = bex * dey;\n    const dexbey = dex * bey;\n    const bd = bexdey - dexbey;\n\n    const alift = aex * aex + aey * aey + aez * aez;\n    const blift = bex * bex + bey * bey + bez * bez;\n    const clift = cex * cex + cey * cey + cez * cez;\n    const dlift = dex * dex + dey * dey + dez * dez;\n\n    const det =\n        (clift * (dez * ab + aez * bd + bez * da) - dlift * (aez * bc - bez * ac + cez * ab)) +\n        (alift * (bez * cd - cez * bd + dez * bc) - blift * (cez * da + dez * ac + aez * cd));\n\n    const aezplus = Math.abs(aez);\n    const bezplus = Math.abs(bez);\n    const cezplus = Math.abs(cez);\n    const dezplus = Math.abs(dez);\n    const aexbeyplus = Math.abs(aexbey) + Math.abs(bexaey);\n    const bexceyplus = Math.abs(bexcey) + Math.abs(cexbey);\n    const cexdeyplus = Math.abs(cexdey) + Math.abs(dexcey);\n    const dexaeyplus = Math.abs(dexaey) + Math.abs(aexdey);\n    const aexceyplus = Math.abs(aexcey) + Math.abs(cexaey);\n    const bexdeyplus = Math.abs(bexdey) + Math.abs(dexbey);\n    const permanent =\n        (cexdeyplus * bezplus + bexdeyplus * cezplus + bexceyplus * dezplus) * alift +\n        (dexaeyplus * cezplus + aexceyplus * dezplus + cexdeyplus * aezplus) * blift +\n        (aexbeyplus * dezplus + bexdeyplus * aezplus + dexaeyplus * bezplus) * clift +\n        (bexceyplus * aezplus + aexceyplus * bezplus + aexbeyplus * cezplus) * dlift;\n\n    const errbound = isperrboundA * permanent;\n    if (det > errbound || -det > errbound) {\n        return det;\n    }\n    return -insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent);\n}\n\nexport function inspherefast(pax, pay, paz, pbx, pby, pbz, pcx, pcy, pcz, pdx, pdy, pdz, pex, pey, pez) {\n    const aex = pax - pex;\n    const bex = pbx - pex;\n    const cex = pcx - pex;\n    const dex = pdx - pex;\n    const aey = pay - pey;\n    const bey = pby - pey;\n    const cey = pcy - pey;\n    const dey = pdy - pey;\n    const aez = paz - pez;\n    const bez = pbz - pez;\n    const cez = pcz - pez;\n    const dez = pdz - pez;\n\n    const ab = aex * bey - bex * aey;\n    const bc = bex * cey - cex * bey;\n    const cd = cex * dey - dex * cey;\n    const da = dex * aey - aex * dey;\n    const ac = aex * cey - cex * aey;\n    const bd = bex * dey - dex * bey;\n\n    const abc = aez * bc - bez * ac + cez * ab;\n    const bcd = bez * cd - cez * bd + dez * bc;\n    const cda = cez * da + dez * ac + aez * cd;\n    const dab = dez * ab + aez * bd + bez * da;\n\n    const alift = aex * aex + aey * aey + aez * aez;\n    const blift = bex * bex + bey * bey + bez * bez;\n    const clift = cex * cex + cey * cey + cez * cez;\n    const dlift = dex * dex + dey * dey + dez * dez;\n\n    return (clift * dab - dlift * abc) + (alift * bcd - blift * cda);\n}\n","import { orient2d } from 'robust-predicates';\n\nfunction pointInPolygon(p, polygon) {\n    var i;\n    var ii;\n    var k = 0;\n    var f;\n    var u1;\n    var v1;\n    var u2;\n    var v2;\n    var currentP;\n    var nextP;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i = 0; i < numContours; i++) {\n        ii = 0;\n        var contour = polygon[i];\n        var contourLen = contour.length - 1;\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            u2 = nextP[0] - x;\n            v2 = nextP[1] - y;\n\n            if (v1 === 0 && v2 === 0) {\n                if ((u2 <= 0 && u1 >= 0) || (u1 <= 0 && u2 >= 0)) { return 0 }\n            } else if ((v2 >= 0 && v1 <= 0) || (v2 <= 0 && v1 >= 0)) {\n                f = orient2d(u1, u2, v1, v2, 0, 0);\n                if (f === 0) { return 0 }\n                if ((f > 0 && v2 > 0 && v1 <= 0) || (f < 0 && v2 <= 0 && v1 > 0)) { k++; }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport { pointInPolygon as default };\n","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport pip from \"point-in-polygon-hao\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nfunction booleanPointInPolygon(point, polygon, options = {}) {\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n  const pt = getCoord(point);\n  const geom = getGeom(polygon);\n  const type = geom.type;\n  const bbox = polygon.bbox;\n  let polys = geom.coordinates;\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  }\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n  let result = false;\n  for (var i = 0; i < polys.length; ++i) {\n    const polyResult = pip(pt, polys[i]);\n    if (polyResult === 0) return options.ignoreBoundary ? false : true;\n    else if (polyResult) result = true;\n  }\n  return result;\n}\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nvar turf_boolean_point_in_polygon_default = booleanPointInPolygon;\nexport {\n  booleanPointInPolygon,\n  turf_boolean_point_in_polygon_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { flattenEach, featureEach } from \"@turf/meta\";\nimport { polygon as polygon2, featureCollection as featureCollection2 } from \"@turf/helpers\";\n\n// lib/geojson-polygon-self-intersections.js\nimport rbush from \"rbush\";\nfunction geojsonPolygonSelfIntersections(feature, filterFn, useSpatialIndex) {\n  if (feature.geometry.type !== \"Polygon\")\n    throw new Error(\"The input feature must be a Polygon\");\n  if (useSpatialIndex === void 0) useSpatialIndex = 1;\n  var coord = feature.geometry.coordinates;\n  var output = [];\n  var seen = {};\n  if (useSpatialIndex) {\n    var allEdgesAsRbushTreeItems = [];\n    for (var ring0 = 0; ring0 < coord.length; ring0++) {\n      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\n      }\n    }\n    var tree = new rbush();\n    tree.load(allEdgesAsRbushTreeItems);\n  }\n  for (var ringA = 0; ringA < coord.length; ringA++) {\n    for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\n      if (useSpatialIndex) {\n        var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\n        bboxOverlaps.forEach(function(bboxIsect) {\n          var ring12 = bboxIsect.ring;\n          var edge12 = bboxIsect.edge;\n          ifIsectAddToOutput(ringA, edgeA, ring12, edge12);\n        });\n      } else {\n        for (var ring1 = 0; ring1 < coord.length; ring1++) {\n          for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n            ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n          }\n        }\n      }\n    }\n  }\n  if (!filterFn)\n    output = {\n      type: \"Feature\",\n      geometry: { type: \"MultiPoint\", coordinates: output }\n    };\n  return output;\n  function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {\n    var start0 = coord[ring02][edge02];\n    var end0 = coord[ring02][edge02 + 1];\n    var start1 = coord[ring12][edge12];\n    var end1 = coord[ring12][edge12 + 1];\n    var isect = intersect(start0, end0, start1, end1);\n    if (isect === null) return;\n    var frac0;\n    var frac1;\n    if (end0[0] !== start0[0]) {\n      frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\n    } else {\n      frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\n    }\n    if (end1[0] !== start1[0]) {\n      frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\n    } else {\n      frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\n    }\n    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;\n    var key = isect;\n    var unique = !seen[key];\n    if (unique) {\n      seen[key] = true;\n    }\n    if (filterFn) {\n      output.push(\n        filterFn(\n          isect,\n          ring02,\n          edge02,\n          start0,\n          end0,\n          frac0,\n          ring12,\n          edge12,\n          start1,\n          end1,\n          frac1,\n          unique\n        )\n      );\n    } else {\n      output.push(isect);\n    }\n  }\n  function rbushTreeItem(ring, edge) {\n    var start = coord[ring][edge];\n    var end = coord[ring][edge + 1];\n    var minX;\n    var maxX;\n    var minY;\n    var maxY;\n    if (start[0] < end[0]) {\n      minX = start[0];\n      maxX = end[0];\n    } else {\n      minX = end[0];\n      maxX = start[0];\n    }\n    if (start[1] < end[1]) {\n      minY = start[1];\n      maxY = end[1];\n    } else {\n      minY = end[1];\n      maxY = start[1];\n    }\n    return {\n      minX,\n      minY,\n      maxX,\n      maxY,\n      ring,\n      edge\n    };\n  }\n}\nfunction intersect(start0, end0, start1, end1) {\n  if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1))\n    return null;\n  var x0 = start0[0], y0 = start0[1], x1 = end0[0], y1 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];\n  var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n  if (denom === 0) return null;\n  var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n  var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n  return [x4, y4];\n}\nfunction equalArrays(array1, array2) {\n  if (!array1 || !array2) return false;\n  if (array1.length !== array2.length) return false;\n  for (var i = 0, l = array1.length; i < l; i++) {\n    if (array1[i] instanceof Array && array2[i] instanceof Array) {\n      if (!equalArrays(array1[i], array2[i])) return false;\n    } else if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// lib/simplepolygon.js\nimport { area } from \"@turf/area\";\nimport { featureCollection, polygon } from \"@turf/helpers\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport rbush2 from \"rbush\";\nfunction simplepolygon(feature) {\n  if (feature.type != \"Feature\")\n    throw new Error(\"The input must a geojson object of type Feature\");\n  if (feature.geometry === void 0 || feature.geometry == null)\n    throw new Error(\n      \"The input must a geojson object with a non-empty geometry\"\n    );\n  if (feature.geometry.type != \"Polygon\")\n    throw new Error(\"The input must be a geojson Polygon\");\n  var numRings = feature.geometry.coordinates.length;\n  var vertices = [];\n  for (var i = 0; i < numRings; i++) {\n    var ring = feature.geometry.coordinates[i];\n    if (!equalArrays2(ring[0], ring[ring.length - 1])) {\n      ring.push(ring[0]);\n    }\n    for (var j = 0; j < ring.length - 1; j++) {\n      vertices.push(ring[j]);\n    }\n  }\n  if (!isUnique(vertices))\n    throw new Error(\n      \"The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)\"\n    );\n  var numvertices = vertices.length;\n  var selfIsectsData = geojsonPolygonSelfIntersections(\n    feature,\n    function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {\n      return [\n        isect,\n        ring0,\n        edge0,\n        start0,\n        end0,\n        frac0,\n        ring1,\n        edge1,\n        start1,\n        end1,\n        frac1,\n        unique\n      ];\n    }\n  );\n  var numSelfIsect = selfIsectsData.length;\n  if (numSelfIsect == 0) {\n    var outputFeatureArray = [];\n    for (var i = 0; i < numRings; i++) {\n      outputFeatureArray.push(\n        polygon([feature.geometry.coordinates[i]], {\n          parent: -1,\n          winding: windingOfRing(feature.geometry.coordinates[i])\n        })\n      );\n    }\n    var output = featureCollection(outputFeatureArray);\n    determineParents();\n    setNetWinding();\n    return output;\n  }\n  var pseudoVtxListByRingAndEdge = [];\n  var isectList = [];\n  for (var i = 0; i < numRings; i++) {\n    pseudoVtxListByRingAndEdge.push([]);\n    for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {\n      pseudoVtxListByRingAndEdge[i].push([\n        new PseudoVtx(\n          feature.geometry.coordinates[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)],\n          1,\n          [i, j],\n          [i, modulo(j + 1, feature.geometry.coordinates[i].length - 1)],\n          void 0\n        )\n      ]);\n      isectList.push(\n        new Isect(\n          feature.geometry.coordinates[i][j],\n          [i, modulo(j - 1, feature.geometry.coordinates[i].length - 1)],\n          [i, j],\n          void 0,\n          void 0,\n          false,\n          true\n        )\n      );\n    }\n  }\n  for (var i = 0; i < numSelfIsect; i++) {\n    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(\n      new PseudoVtx(\n        selfIsectsData[i][0],\n        selfIsectsData[i][5],\n        [selfIsectsData[i][1], selfIsectsData[i][2]],\n        [selfIsectsData[i][6], selfIsectsData[i][7]],\n        void 0\n      )\n    );\n    if (selfIsectsData[i][11])\n      isectList.push(\n        new Isect(\n          selfIsectsData[i][0],\n          [selfIsectsData[i][1], selfIsectsData[i][2]],\n          [selfIsectsData[i][6], selfIsectsData[i][7]],\n          void 0,\n          void 0,\n          true,\n          true\n        )\n      );\n  }\n  var numIsect = isectList.length;\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n      pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {\n        return a.param < b.param ? -1 : 1;\n      });\n    }\n  }\n  var allIsectsAsIsectRbushTreeItem = [];\n  for (var i = 0; i < numIsect; i++) {\n    allIsectsAsIsectRbushTreeItem.push({\n      minX: isectList[i].coord[0],\n      minY: isectList[i].coord[1],\n      maxX: isectList[i].coord[0],\n      maxY: isectList[i].coord[1],\n      index: i\n    });\n  }\n  var isectRbushTree = new rbush2();\n  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n        var coordToFind;\n        if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {\n          coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)][0].coord;\n        } else {\n          coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\n        }\n        var IsectRbushTreeItemFound = isectRbushTree.search({\n          minX: coordToFind[0],\n          minY: coordToFind[1],\n          maxX: coordToFind[0],\n          maxY: coordToFind[1]\n        })[0];\n        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;\n      }\n    }\n  }\n  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\n        var IsectRbushTreeItemFound = isectRbushTree.search({\n          minX: coordToFind[0],\n          minY: coordToFind[1],\n          maxX: coordToFind[0],\n          maxY: coordToFind[1]\n        })[0];\n        var l = IsectRbushTreeItemFound.index;\n        if (l < numvertices) {\n          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n        } else {\n          if (equalArrays2(\n            isectList[l].ringAndEdge1,\n            pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn\n          )) {\n            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n          } else {\n            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n          }\n        }\n      }\n    }\n  }\n  var queue = [];\n  var i = 0;\n  for (var j = 0; j < numRings; j++) {\n    var leftIsect = i;\n    for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {\n      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\n        leftIsect = i;\n      }\n      i++;\n    }\n    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\n    for (var k = 0; k < isectList.length; k++) {\n      if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {\n        var isectBeforeLeftIsect = k;\n        break;\n      }\n    }\n    var windingAtIsect = isConvex(\n      [\n        isectList[isectBeforeLeftIsect].coord,\n        isectList[leftIsect].coord,\n        isectList[isectAfterLeftIsect].coord\n      ],\n      true\n    ) ? 1 : -1;\n    queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });\n  }\n  queue.sort(function(a, b) {\n    return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;\n  });\n  var outputFeatureArray = [];\n  while (queue.length > 0) {\n    var popped = queue.pop();\n    var startIsect = popped.isect;\n    var currentOutputRingParent = popped.parent;\n    var currentOutputRingWinding = popped.winding;\n    var currentOutputRing = outputFeatureArray.length;\n    var currentOutputRingCoords = [isectList[startIsect].coord];\n    var currentIsect = startIsect;\n    if (isectList[startIsect].ringAndEdge1Walkable) {\n      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\n      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\n    } else {\n      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\n      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\n    }\n    while (!equalArrays2(isectList[startIsect].coord, isectList[nxtIsect].coord)) {\n      currentOutputRingCoords.push(isectList[nxtIsect].coord);\n      var nxtIsectInQueue = void 0;\n      for (var i = 0; i < queue.length; i++) {\n        if (queue[i].isect == nxtIsect) {\n          nxtIsectInQueue = i;\n          break;\n        }\n      }\n      if (nxtIsectInQueue != void 0) {\n        queue.splice(nxtIsectInQueue, 1);\n      }\n      if (equalArrays2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\n        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\n        isectList[nxtIsect].ringAndEdge2Walkable = false;\n        if (isectList[nxtIsect].ringAndEdge1Walkable) {\n          var pushing = { isect: nxtIsect };\n          if (isConvex(\n            [\n              isectList[currentIsect].coord,\n              isectList[nxtIsect].coord,\n              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord\n            ],\n            currentOutputRingWinding == 1\n          )) {\n            pushing.parent = currentOutputRingParent;\n            pushing.winding = -currentOutputRingWinding;\n          } else {\n            pushing.parent = currentOutputRing;\n            pushing.winding = currentOutputRingWinding;\n          }\n          queue.push(pushing);\n        }\n        currentIsect = nxtIsect;\n        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\n      } else {\n        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\n        isectList[nxtIsect].ringAndEdge1Walkable = false;\n        if (isectList[nxtIsect].ringAndEdge2Walkable) {\n          var pushing = { isect: nxtIsect };\n          if (isConvex(\n            [\n              isectList[currentIsect].coord,\n              isectList[nxtIsect].coord,\n              isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord\n            ],\n            currentOutputRingWinding == 1\n          )) {\n            pushing.parent = currentOutputRingParent;\n            pushing.winding = -currentOutputRingWinding;\n          } else {\n            pushing.parent = currentOutputRing;\n            pushing.winding = currentOutputRingWinding;\n          }\n          queue.push(pushing);\n        }\n        currentIsect = nxtIsect;\n        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\n      }\n    }\n    currentOutputRingCoords.push(isectList[nxtIsect].coord);\n    outputFeatureArray.push(\n      polygon([currentOutputRingCoords], {\n        index: currentOutputRing,\n        parent: currentOutputRingParent,\n        winding: currentOutputRingWinding,\n        netWinding: void 0\n      })\n    );\n  }\n  var output = featureCollection(outputFeatureArray);\n  determineParents();\n  setNetWinding();\n  function determineParents() {\n    var featuresWithoutParent = [];\n    for (var i2 = 0; i2 < output.features.length; i2++) {\n      if (output.features[i2].properties.parent == -1)\n        featuresWithoutParent.push(i2);\n    }\n    if (featuresWithoutParent.length > 1) {\n      for (var i2 = 0; i2 < featuresWithoutParent.length; i2++) {\n        var parent = -1;\n        var parentArea = Infinity;\n        for (var j2 = 0; j2 < output.features.length; j2++) {\n          if (featuresWithoutParent[i2] == j2) continue;\n          if (booleanPointInPolygon(\n            output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0],\n            output.features[j2],\n            { ignoreBoundary: true }\n          )) {\n            if (area(output.features[j2]) < parentArea) {\n              parent = j2;\n            }\n          }\n        }\n        output.features[featuresWithoutParent[i2]].properties.parent = parent;\n      }\n    }\n  }\n  function setNetWinding() {\n    for (var i2 = 0; i2 < output.features.length; i2++) {\n      if (output.features[i2].properties.parent == -1) {\n        var netWinding = output.features[i2].properties.winding;\n        output.features[i2].properties.netWinding = netWinding;\n        setNetWindingOfChildren(i2, netWinding);\n      }\n    }\n  }\n  function setNetWindingOfChildren(parent, ParentNetWinding) {\n    for (var i2 = 0; i2 < output.features.length; i2++) {\n      if (output.features[i2].properties.parent == parent) {\n        var netWinding = ParentNetWinding + output.features[i2].properties.winding;\n        output.features[i2].properties.netWinding = netWinding;\n        setNetWindingOfChildren(i2, netWinding);\n      }\n    }\n  }\n  return output;\n}\nvar PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {\n  this.coord = coord;\n  this.param = param;\n  this.ringAndEdgeIn = ringAndEdgeIn;\n  this.ringAndEdgeOut = ringAndEdgeOut;\n  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;\n};\nvar Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {\n  this.coord = coord;\n  this.ringAndEdge1 = ringAndEdge1;\n  this.ringAndEdge2 = ringAndEdge2;\n  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;\n  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;\n  this.ringAndEdge1Walkable = ringAndEdge1Walkable;\n  this.ringAndEdge2Walkable = ringAndEdge2Walkable;\n};\nfunction isConvex(pts, righthanded) {\n  if (typeof righthanded === \"undefined\") righthanded = true;\n  if (pts.length != 3)\n    throw new Error(\"This function requires an array of three points [x,y]\");\n  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\n  return d >= 0 == righthanded;\n}\nfunction windingOfRing(ring) {\n  var leftVtx = 0;\n  for (var i = 0; i < ring.length - 1; i++) {\n    if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;\n  }\n  if (isConvex(\n    [\n      ring[modulo(leftVtx - 1, ring.length - 1)],\n      ring[leftVtx],\n      ring[modulo(leftVtx + 1, ring.length - 1)]\n    ],\n    true\n  )) {\n    var winding = 1;\n  } else {\n    var winding = -1;\n  }\n  return winding;\n}\nfunction equalArrays2(array1, array2) {\n  if (!array1 || !array2) return false;\n  if (array1.length != array2.length) return false;\n  for (var i = 0, l = array1.length; i < l; i++) {\n    if (array1[i] instanceof Array && array2[i] instanceof Array) {\n      if (!equalArrays2(array1[i], array2[i])) return false;\n    } else if (array1[i] != array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction modulo(n, m) {\n  return (n % m + m) % m;\n}\nfunction isUnique(array) {\n  var u = {};\n  var isUnique2 = 1;\n  for (var i = 0, l = array.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(u, array[i])) {\n      isUnique2 = 0;\n      break;\n    }\n    u[array[i]] = 1;\n  }\n  return isUnique2;\n}\n\n// index.ts\nfunction unkinkPolygon(geojson) {\n  var features = [];\n  flattenEach(geojson, function(feature) {\n    if (feature.geometry.type !== \"Polygon\") return;\n    featureEach(simplepolygon(feature), function(poly) {\n      features.push(polygon2(poly.geometry.coordinates, feature.properties));\n    });\n  });\n  return featureCollection2(features);\n}\nvar turf_unkink_polygon_default = unkinkPolygon;\nexport {\n  turf_unkink_polygon_default as default,\n  unkinkPolygon\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport {\n  featureCollection,\n  isNumber,\n  isObject,\n  lineString,\n  point,\n  polygon,\n  validateBBox\n} from \"@turf/helpers\";\nfunction randomPosition(bbox) {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\nfunction randomPositionUnchecked(bbox) {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\nfunction checkBBox(bbox) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\nfunction randomPoint(count, options = {}) {\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\nfunction randomPolygon(count, options = {}) {\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (options.bbox === void 0 || options.bbox === null) {\n    options.bbox = [-180, -90, 180, 90];\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {\n    options.num_vertices = 10;\n  }\n  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {\n    options.max_radial_length = 10;\n  }\n  const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);\n  const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);\n  const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);\n  if (options.max_radial_length > maxRadius) {\n    throw new Error(\"max_radial_length is greater than the radius of the bbox\");\n  }\n  const paddedBbox = [\n    options.bbox[0] + options.max_radial_length,\n    options.bbox[1] + options.max_radial_length,\n    options.bbox[2] - options.max_radial_length,\n    options.bbox[3] - options.max_radial_length\n  ];\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n    circleOffsets.forEach((cur) => {\n      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([\n        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n        radialScaler * (options.max_radial_length || 10) * Math.cos(cur)\n      ]);\n    });\n    vertices[vertices.length - 1] = vertices[0];\n    vertices = vertices.reverse().map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\nfunction randomLineString(count, options = {}) {\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === void 0) {\n    max_length = 1e-4;\n  }\n  if (!isNumber(max_rotation) || max_rotation === void 0) {\n    max_rotation = Math.PI / 8;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan(\n        (vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0])\n      );\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([\n        vertices[j][0] + distance * Math.cos(angle),\n        vertices[j][1] + distance * Math.sin(angle)\n      ]);\n    }\n    features.push(lineString(vertices));\n  }\n  return featureCollection(features);\n}\nfunction vertexToCoordinate(hub) {\n  return (cur) => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\nfunction coordInBBox(bbox) {\n  return [\n    Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n    Math.random() * (bbox[3] - bbox[1]) + bbox[1]\n  ];\n}\nexport {\n  randomLineString,\n  randomPoint,\n  randomPolygon,\n  randomPosition\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { coordEach } from \"@turf/meta\";\nfunction bbox(geojson, options = {}) {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nvar turf_bbox_default = bbox;\nexport {\n  bbox,\n  turf_bbox_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { booleanPointInPolygon as pointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, multiPoint } from \"@turf/helpers\";\nimport { geomEach, featureEach, coordEach } from \"@turf/meta\";\nfunction pointsWithinPolygon(points, polygons) {\n  const results = [];\n  featureEach(points, function(point) {\n    let contained = false;\n    if (point.geometry.type === \"Point\") {\n      geomEach(polygons, function(polygon) {\n        if (pointInPolygon(point, polygon)) {\n          contained = true;\n        }\n      });\n      if (contained) {\n        results.push(point);\n      }\n    } else if (point.geometry.type === \"MultiPoint\") {\n      var pointsWithin = [];\n      geomEach(polygons, function(polygon) {\n        coordEach(point, function(pointCoord) {\n          if (pointInPolygon(pointCoord, polygon)) {\n            contained = true;\n            pointsWithin.push(pointCoord);\n          }\n        });\n      });\n      if (contained) {\n        results.push(\n          multiPoint(pointsWithin, point.properties)\n        );\n      }\n    } else {\n      throw new Error(\"Input geometry must be a Point or MultiPoint\");\n    }\n  });\n  return featureCollection(results);\n}\nvar turf_points_within_polygon_default = pointsWithinPolygon;\nexport {\n  turf_points_within_polygon_default as default,\n  pointsWithinPolygon\n};\n//# sourceMappingURL=index.js.map","import unkinkPolygon from '@turf/unkink-polygon';\nimport {randomPoint} from '@turf/random';\nimport {bbox} from '@turf/bbox';\nimport pointsWithinPolygon from '@turf/points-within-polygon';\nimport {featureCollection} from '@turf/helpers';\n\n/**\n * turf wrapper\n */\nconst turf = {\n  randomPoint,\n  unkinkPolygon,\n  bbox,\n  pointsWithinPolygon,\n  featureCollection,\n};\n\nexport default turf;\n","import turf from './turf';\n\nconst DEFAULT_NUMBER = 10;\n\nconst randomPoints = (n: number, bbox?: GeoJSON.BBox) => {\n  const count = n || DEFAULT_NUMBER;\n  return turf.randomPoint(count, {\n    bbox,\n  });\n};\n\nconst randomPointsFromGeoJSON = (\n  input: number,\n  { features, unkink }: { features: GeoJSON.FeatureCollection; unkink: boolean }\n) => {\n  let fc;\n  if (unkink) {\n    // @ts-expect-error TODO: fix this\n    fc = turf.unkinkPolygon(features);\n  } else {\n    fc = features;\n  }\n\n  const ori = input || DEFAULT_NUMBER;\n  const randomFeatures: GeoJSON.Feature<\n    GeoJSON.Point,\n    GeoJSON.GeoJsonProperties\n  >[] = [];\n  const bbox = turf.bbox(fc);\n  let n = ori;\n  let flag = false;\n  let joker = 0;\n\n  while (!flag) {\n    const thePoints = turf.randomPoint(n, {\n      bbox,\n    });\n    joker += 1;\n    // @ts-expect-error TODO: fix this\n    const ptsWithin = turf.pointsWithinPolygon(thePoints, fc);\n    for (let i = 0; i < ptsWithin.features.length; i += 1) {\n      const feature = ptsWithin.features[i];\n      if (feature !== undefined && feature.geometry.type === 'Point') {\n        randomFeatures.push(\n          feature as GeoJSON.Feature<GeoJSON.Point, GeoJSON.GeoJsonProperties>\n        );\n      }\n    }\n    if (randomFeatures.length < ori) {\n      n = ori - randomFeatures.length;\n    } else {\n      flag = true;\n    }\n    if (joker > ori * 10000) {\n      throw new Error(\n        'Your are not lucky. Ending without reaching expected number of Points with input polygon(s)'\n      );\n    }\n  }\n  return turf.featureCollection(randomFeatures);\n};\n\n/**\n * Creates random points and returns it as a FeatureCollecion\n * @param  {Number} number of points to generate\n * @param  {Object} options for random [bbox|input]\n * @return FeatureCollection generated random points\n */\nexport function random(\n  n: number,\n  options: {\n    bbox?: GeoJSON.BBox;\n    features?: GeoJSON.FeatureCollection;\n    unkink?: boolean;\n  }\n): GeoJSON.FeatureCollection {\n  let points;\n  let params = { ...options };\n  if (typeof params === 'undefined') {\n    params = { unkink: true };\n  }\n  if (typeof params.unkink === 'undefined') {\n    params.unkink = true;\n  }\n\n  // console.debug('params', params);\n  if (typeof params.features !== 'undefined') {\n    points = randomPointsFromGeoJSON(n, {\n      features: params.features,\n      unkink: params.unkink,\n    });\n  } else {\n    points = randomPoints(n, params.bbox);\n  }\n\n  return points as GeoJSON.FeatureCollection<\n    GeoJSON.Geometry,\n    GeoJSON.GeoJsonProperties\n  >;\n}\n\nexport default { random };\n"],"names":["t","i","r","e","a","h","n","o","s","l","Math","f","u","m","c","p","d","x","v","M","__webpack_require__","definition","key","Object","obj","prop","Symbol","earthRadius","geom","properties","options","feat","coordinates","Error","Array","ring","j","features","fc","multiPoint","num","isNaN","validateBBox","bbox","coordEach","geojson","callback","excludeWrapCoord","k","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","initialValue","previousValue","currentGeometry","flattenEach","id","coordinate","value","calculateArea","total","polygonArea","ringArea","FACTOR","PI_OVER_180","coordsLength","lower","middle","upper","lowerX","middleY","upperX","epsilon","elen","flen","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","Float64Array","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","pointInPolygon","polygon","ii","u1","v1","u2","v2","currentP","nextP","y","numContours","contour","contourLen","getCoord","coord","getGeom","booleanPointInPolygon","point","pt","polys","inBBox","result","polyResult","geojsonPolygonSelfIntersections","feature","filterFn","useSpatialIndex","output","seen","allEdgesAsRbushTreeItems","ring0","edge0","rbushTreeItem","tree","ringA","edgeA","bboxOverlaps","bboxIsect","ring12","edge12","ifIsectAddToOutput","ring1","edge1","ring02","edge02","start0","end0","start1","end1","isect","intersect","frac0","frac1","unique","edge","start","end","minX","maxX","minY","maxY","equalArrays","x0","y0","x1","y1","x2","y2","x3","y3","denom","x4","y4","array1","array2","simplepolygon","numRings","vertices","equalArrays2","isUnique","numvertices","selfIsectsData","numSelfIsect","outputFeatureArray","windingOfRing","determineParents","setNetWinding","pseudoVtxListByRingAndEdge","isectList","PseudoVtx","modulo","Isect","numIsect","b","allIsectsAsIsectRbushTreeItem","isectRbushTree","coordToFind","IsectRbushTreeItemFound","queue","leftIsect","isectAfterLeftIsect","isectBeforeLeftIsect","windingAtIsect","isConvex","popped","startIsect","currentOutputRingParent","currentOutputRingWinding","currentOutputRing","currentOutputRingCoords","currentIsect","walkingRingAndEdge","nxtIsect","nxtIsectInQueue","pushing","featuresWithoutParent","i2","parent","parentArea","j2","netWinding","setNetWindingOfChildren","ParentNetWinding","param","ringAndEdgeIn","ringAndEdgeOut","nxtIsectAlongEdgeIn","ringAndEdge1","ringAndEdge2","nxtIsectAlongRingAndEdge1","nxtIsectAlongRingAndEdge2","ringAndEdge1Walkable","ringAndEdge2Walkable","pts","righthanded","leftVtx","winding","array","isUnique2","unkinkPolygon","poly","turf_unkink_polygon_default","randomPositionUnchecked","coordInBBox","lon","lat","checkBBox","randomPoint","count","rnd","pointsWithinPolygon","points","polygons","results","contained","pointsWithin","pointCoord","turf_points_within_polygon_default","turf","featureCollection","DEFAULT_NUMBER","randomPoints","randomPointsFromGeoJSON","input","unkink","ori","randomFeatures","flag","joker","thePoints","ptsWithin","undefined","random","params"],"mappings":"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"}